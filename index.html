<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Lambda Behave : A modern testing and behavioural specification framework for Java 8">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Lambda Behave</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/RichardWarburton/lambda-behave">View on GitHub</a>

          <h1 id="project_title">Lambda Behave</h1>
          <h2 id="project_tagline">A modern testing and behavioural specification framework for Java 8</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/RichardWarburton/lambda-behave/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/RichardWarburton/lambda-behave/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a name="introduction" class="anchor" href="#introduction"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>If you're a Java developer and you've seen the fluent, modern specification frameworks available in other programming languages such as spock or jasmine then Lambda Behave is for you. Its goal is to make testing a more pleasant experience than it currently is with junit.</p>

<p>The <a href="https://raw.githubusercontent.com/RichardWarburton/lambda-behave/master/CHANGELOG.md">changelog</a> explains what features have been added in each release.</p>

<h3>
<a name="fluent-specifications" class="anchor" href="#fluent-specifications"><span class="octicon octicon-link"></span></a>Fluent Specifications</h3>

<p>The Lambda Behave Specification design has several goals in mind:</p>

<ul>
<li>To read like plain English.</li>
<li>To encourage describing tests using long and descriptive sentences, rather than a few words.</li>
<li>An API that is fluent and discoverable nearly entirely through IDE auto-completion.</li>
</ul><pre><code>public class StackSpec {{

    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();

    describe("a stack", it -&gt; {

        it.isSetupWith(stack::clear);

        it.isConcludedWith(stack::clear);

        it.should("be empty when created", expect -&gt; {
            expect.that(stack).isEmpty();
        });
</code></pre>

<p>There are many, many, expectations builtin to the framework - not just <code>isEmpty()</code>. </p>

<p>Every specification suite starts its declaration using the <code>Suite.describe</code> method. From that point onwards your IDE should be able to auto-complete the domain specific language for declaring specifications, but just in case you want more information, here's the details.</p>

<ul>
<li>If you want to specify a property about your system use <code>it.should</code>.</li>
<li>If you want describe an expectation of that property, use <code>expect.that</code>. This will get you to a fluent API restricted to the type of value that you're making the expectation about. The expectation system is based upon hamcrest. Lambda Behave doesn't compromise the ability to compose matchers in favour of fluency - if you want to compose in more complex flavours simply use <code>expect.that(value).is()</code> and then you can use regular Hamcrest matchers. In my experience this is a rare, albeit useful, breakout option.</li>
<li>If you want to setup or teardown data before or after each specification use <code>it.shouldSetup</code> and <code>it.shouldTearDown</code>.</li>
<li>If you want to setup or teardown data before or after each suite use <code>it.shouldInitialize</code> and <code>it.shouldComplete</code>.</li>
<li>Don't worry - I know some Java 8 lambdafied APIs don't deal with exceptions very well but you can throw exceptions in all our callbacks and the appropriate error will be reported, not just break the library.</li>
</ul><h3>
<a name="data-driven-specifications" class="anchor" href="#data-driven-specifications"><span class="octicon octicon-link"></span></a>Data Driven Specifications</h3>

<p>The ability to parametrise specifications by different data inputs.
Data driven tests in TestNG or the <code>@Parameterized</code> junit annotation perform a similar task. 
<code>@Parameterized</code> only parameterises at the level of a class, whereas Lambda Behave parameterises at the level of a specification. </p>

<pre><code>describe("a pair of numbers", it -&gt; {
    it.uses(2, 4)
      .and(4, 8)
      .toShow("%d / %d is two", (expect, x, y) -&gt; {
          expect.that(y / x).is(2);
      });
});
</code></pre>

<p>The API in Lambda Behave is both fluent and also type safe and doesn't rely on reflection magic.
The <code>uses</code> method is overloaded to allow a different number of columns of data to be used. It also supports taking
streams or lists of data as its inputs, rather than explicitly chaining individual values.</p>

<p>Not only is the specification parameterised by the data, but the description is also parameterised, its name being interpreted as a format <code>String</code>. 
The aforementioned test would output the following:</p>

<pre><code>a pair of numbers
  2 / 4 is two
  8 / 4 is two
</code></pre>

<h3>
<a name="generated-specifications" class="anchor" href="#generated-specifications"><span class="octicon octicon-link"></span></a>Generated Specifications</h3>

<p>Lambda Behave can automatically generate testcases for your to test your code with, similar to quick check or scala check.
The Fluent API for this is similar to data driven specifications allows for control over the way that the values are generated
and how many need to be generated. Here is an example of how to show that reversing a <code>String</code> twice returns the same <code>String</code>
using randomly generated test case values.</p>

<pre><code>it.requires(10)
  .example(asciiStrings())
  .toShow("reversing a String twice returns the original String", (expect, str) -&gt; {
      String same = new StringBuilder(str).reverse().reverse().toString();
      expect.that(same).isEqualTo(str);
  });
</code></pre>

<p>All generated specifications follow this common pattern where;</p>

<ul>
<li>The <code>require</code> clause expresses how many values to generate,</li>
<li>The <code>example</code> clause states what type of objects to generate and how to generate them, This is overloaded to allow multiple columns of testcase values to be generated.</li>
<li>The <code>toShow</code> clause behaves like a <code>toShow</code> clause for a data drive spec. It is type safe against the the different columns.
So in the above example the paramter <code>str</code> will have had its type correctly inferred as <code>String</code>. </li>
</ul><h3>
<a name="downloading-lambda-behave" class="anchor" href="#downloading-lambda-behave"><span class="octicon octicon-link"></span></a>Downloading Lambda Behave</h3>

<p>If you're using a maven project then you can download Lambda Behave using the following pom entry.</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.insightfullogic&lt;/groupId&gt;
    &lt;artifactId&gt;lambda-behave&lt;/artifactId&gt;
    &lt;version&gt;0.3&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>If you're using a gradle project then you can use:</p>

<pre><code>testCompile group: 'com.insightfullogic', name: 'lambda-behave', version: '0.3'
</code></pre>

<p>There's also an <a href="https://github.com/RichardWarburton/lambda-behave/tree/lambda-behave-parent-0.3/lambda-behave-examples">example project</a>
and there's published <a href="http://javadoc.insightfullogic.com">Javadoc</a>.</p>

<h3>
<a name="junit-integration" class="anchor" href="#junit-integration"><span class="octicon octicon-link"></span></a>Junit Integration</h3>

<p>Lambda Behave also offers a junit runner. This lets you easily integrate into existing your existing test suite, or the tests via an Eclipse, Intellij, Netbeans, Maven, Gradle or Ant. You just add an annotation to enable this,
and it can be run through your normal tooling.</p>

<pre><code>@RunWith(JunitSuiteRunner.class)
public class StackSpec {{
</code></pre>

<h3>
<a name="lambdas---what-the-hell-are-they" class="anchor" href="#lambdas---what-the-hell-are-they"><span class="octicon octicon-link"></span></a>Lambdas - what the hell are they?</h3>

<p>Conveniently I've written a <a href="http://shop.oreilly.com/product/0636920030713.do?cmp=af-prog-books-videos-product_cj_9781491900154_%25zp'">book</a> on Lambda expressions in Java 8 and the cleaner code they enable!</p>

<h3>
<a name="more-details-and-how-to-contribute" class="anchor" href="#more-details-and-how-to-contribute"><span class="octicon octicon-link"></span></a>More Details and How to contribute</h3>

<p><a href="https://github.com/RichardWarburton/lambda-behave/wiki">The wiki</a> has more information.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Lambda Behave maintained by <a href="https://github.com/RichardWarburton">RichardWarburton</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-25501442-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
